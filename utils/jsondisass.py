# ropmemu framework - jsondisass
# 
# Simple/quick JSON parser and manipulation tool. 
# Print assembly instructions and it works directly 
# on the JSON traces generated by ropemu.
#


import sys, json, gzip, argparse
from collections import OrderedDict


def load_filename(name):
    SUPPORTED_EXT = ['json', 'gz']
    ext = name.split('.')[-1]
    if ext.lower() not in SUPPORTED_EXT: 
        print "[-] Extension not supported."
        return None
    print "[+] Getting %s" % name
    if ext.lower() == 'gz':
        gf = gzip.open(name)
        content = json.loads(gf.read(), object_pairs_hook = OrderedDict)
        gf.close()
        return content
    else:
        jf = open(name)
        content = json.load(jf, object_pairs_hook = OrderedDict)
        jf.close()
        return content
 
def main():
    parser = argparse.ArgumentParser(description = 'ROPMEMU framework - jsondisass')
    parser.add_argument("-b", "--begin", action = "store", type = int,
                        dest = "begin", default = 1, help = "From instruction X") 
    parser.add_argument("-e", "--end", action = "store", type = int,
                        dest = "end", default = 10, help = "To instruction Y") 
    parser.add_argument("-B", "--BEGIN", action = "store", type = int,
                        dest = "BEGIN", default = None, help = "From Gadget X") 
    parser.add_argument("-E", "--END", action = "store", type = int,
                        dest = "END", default = None, help = "To Gadget Y")
    parser.add_argument("-c", "--cut", action = "store", type = str,
                        dest = "cut", default = None, help = "Cut input JSON \
                        file and copy the content from -B to -E in the new file")
    parser.add_argument("-s", "--search", action = "store", type = str,
                        dest = "search", default = None, help = "Search \
                        instruction/value/reg")
    parser.add_argument("-f", "--file", action = "store", type = str,
                        dest = "filename", default = None, help = "File \
                        containing the instructions (json/gz)")  
    parser.add_argument("-r", "--replace", action = "store", type = str,
                        dest = "replace", default = None, help = "Replace the \
                        matching entries in the input json") 
    res = parser.parse_args()
  
    print "[-- ROPMEMU framework - jsondisass --]"

    if not res.filename:
        print "[-] Please specify a filename"
        parser.print_help()
        sys.exit(1)

    data = load_filename(res.filename)
    if not data:
        print "[-] Something went wrong. Supported extensions (json/gz)"
        sys.exit(1)
    
    inum = 0
    stop = 0

    if res.replace:
        good = load_filename(res.replace)
        if not good:
            print "[-] Something went wrong. Supported extensions (json/gz)"
            sys.exit(1)
        for key, value in good.items():
            if key in data.keys():
                data[key] = value 
        dump_name = "%s_in_%s" % (res.replace, res.filename)
        fd = open(dump_name, 'w')
        print "\n[+] Dumping %s" % dump_name
        json.dump(data, fd, indent = 2)
        fd.close()
        sys.exit(1)

    if not res.BEGIN and not res.END:
        # Instructions loop. The most used
        for k1, v1 in data.items():
            if stop == 1: break
            for k2, v2 in v1.items():
                for k3, v3 in v2.items():
                    inum += 1 
                    # Skip ret.
                    if k3.lower() == 'ret':
                        inum -= 1
                        continue
                    if inum < res.begin: continue
                    if not res.search:
                        print "%d) %s" % (inum, k3.lower())
                    else:
                        if res.search.lower() in k3.lower():
                            print k1, inum, k3.lower()
                    if inum >= res.end: stop = 1
    else:
        if not res.cut:
            for k1, v1 in data.items():  
                gaddr, gnum = k1.split('-')
                if int(gnum) < res.BEGIN: continue
                if int(gnum) > res.END: break
                if not res.search:
                    print "[ Gadget: %d" % int(gnum)
                for k2, v2 in v1.items():
                    for k3, v3 in v2.items():
                        inum += 1 
                        if res.search:
                            if res.search.lower() in k3.lower():
                                print k1, inum, k3.lower()
                        else:
                            print "%d) %s" % (inum, k3.lower())
        else:
            subset = OrderedDict()
            for k1, v1 in data.items():
                if stop == 1: break
                gaddr, gnum = k1.split('-')
                if int(gnum) < res.BEGIN: continue
                if int(gnum) > res.END: break
                print k1
                subset[k1] = v1
            fd = open(res.cut, 'w')
            print "\n[+] Dumping %s" % res.cut
            json.dump(subset, fd, indent = 2)
            fd.close()

  
main()
